<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPS-Aware Panorama Strip</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #121212;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 { margin: 10px 0; }
    video, canvas {
      border: 1px solid #333;
      margin: 5px;
    }
    #captureBtn {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: 5px solid white;
      background: none;
      margin: 10px;
      transition: 0.2s;
    }
    #captureBtn.recording {
      border-color: red;
    }
    #controls {
      margin: 10px;
    }
    button {
      background: #1e88e5;
      color: white;
      padding: 8px 16px;
      margin: 5px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #1565c0;
    }
    #bottomPreview {
      overflow-x: auto;
      max-width: 100%;
    }
    #stitchedPreview {
      max-height: 150px;
    }
  </style>
</head>
<body>
  <h1>Live GPS-Based Strip</h1>

  <video id="camera" autoplay playsinline width="320" height="240"></video>
  <button id="captureBtn"></button>

  <div id="controls">
    <button id="downloadBtn">Download Strip</button>
    <button onclick="resetCanvas()">Clear All</button>
  </div>

  <div id="bottomPreview">
    <canvas id="stitchedPreview"></canvas>
  </div>

  <script>
    const video = document.getElementById('camera');
    const captureBtn = document.getElementById('captureBtn');
    const previewCanvas = document.getElementById('stitchedPreview');
    const previewCtx = previewCanvas.getContext('2d');
    const downloadBtn = document.getElementById('downloadBtn');

    let capturedImages = [];
    let lastGPS = null;
    let lastCaptureTime = 0;
    const MIN_DISTANCE_METERS = 3; // How far to move before next frame (based on camera FOV)
    const CAPTURE_OFFSET_MS = 100; // 0.1s early capture

    let isRecording = false;

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
      video.srcObject = stream;
    }

    function captureFrame() {
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0);
      return canvas;
    }

    function updateStitchedPreview() {
      const totalWidth = capturedImages.reduce((acc, img) => acc + img.canvas.width, 0);
      const maxHeight = Math.max(...capturedImages.map(img => img.canvas.height));

      previewCanvas.width = totalWidth;
      previewCanvas.height = maxHeight;

      let x = 0;
      capturedImages.forEach(img => {
        previewCtx.drawImage(img.canvas, x, 0);
        x += img.canvas.width;
      });
    }

    function getDistanceFromLatLonInMeters(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // Radius of the earth in m
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function maybeCaptureFrame(position) {
      const now = Date.now();

      if (lastGPS) {
        const dist = getDistanceFromLatLonInMeters(
          lastGPS.coords.latitude, lastGPS.coords.longitude,
          position.coords.latitude, position.coords.longitude
        );

        if (dist >= MIN_DISTANCE_METERS && now - lastCaptureTime > CAPTURE_OFFSET_MS) {
          lastCaptureTime = now;
          lastGPS = position;

          // 0.1s delay to simulate “early” capture due to motion
          setTimeout(() => {
            const canvas = captureFrame();
            capturedImages.push({ canvas, gps: position.coords });
            updateStitchedPreview();
            console.log("Captured frame at", position.coords);
          }, CAPTURE_OFFSET_MS);
        }
      } else {
        lastGPS = position;
      }
    }

    function resetCanvas() {
      capturedImages = [];
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
    }

    captureBtn.addEventListener('click', () => {
      isRecording = !isRecording;
      captureBtn.classList.toggle('recording');
    });

    downloadBtn.addEventListener('click', () => {
      if (capturedImages.length === 0) return;
      const exportCanvas = document.createElement('canvas');
      const totalWidth = capturedImages.reduce((acc, img) => acc + img.canvas.width, 0);
      const maxHeight = Math.max(...capturedImages.map(img => img.canvas.height));
      exportCanvas.width = totalWidth;
      exportCanvas.height = maxHeight;
      const exportCtx = exportCanvas.getContext('2d');

      let x = 0;
      capturedImages.forEach(img => {
        exportCtx.drawImage(img.canvas, x, 0);
        x += img.canvas.width;
      });

      const link = document.createElement('a');
      link.download = 'gps_strip.png';
      link.href = exportCanvas.toDataURL();
      link.click();
    });

    // Start watching GPS
    function startGPS() {
      navigator.geolocation.watchPosition((pos) => {
        if (isRecording) maybeCaptureFrame(pos);
      }, err => {
        console.error('GPS error:', err);
      }, {
        enableHighAccuracy: true,
        maximumAge: 100,
        timeout: 5000
      });
    }

    startCamera();
    startGPS();
  </script>
</body>
</html>
